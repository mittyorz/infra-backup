#!/bin/sh

set -u
set -e

usage () {
    cat << EOF
usage: $0 [-c config file] [-h hostname] [-p sshd port] [-k ssh private key]
          [-u username] [-m module name] [-o rsync option] [-l logfile]
          [-d backup source]

 -c: specify configuration file path

 -h: specify hostname to send backup data

 -p: port number of sshd
     default is '22'

 -k: specify ssh private key path

 -u: username of ssh session
     default is current username

 -m: specify module name for rsyncd

 -o: specify rsync option
     default is "--quiet -a --compress --hard-links --xattrs --delete --force --super --numeric-ids --relative --timeout 600"

 -l: specify log file path
     default is '/var/log/backup/`backup-hostname`.log'

 -d: local directory path to be backuped
     (multiple -d is acceptable)

EOF
}

if [ $# -eq 0 ]; then
    usage
    exit 1
fi

warn () {
    >&2 echo "$0: $@"
}

isexist () {
    [ -e "$1" ] && return 0
    warn "$1 does not exist"
    exit 1
}


# parse commandline arguments
__BACKUPLIST=''
while getopts "c:h:p:k:u:d:" OPT; do
    case $OPT in
        c)  CONFFILE="$OPTARG"
            isexist "$CONFFILE"
            # load configuration
            . $CONFFILE
            ;;
        h)  BACKUPHOST="$OPTARG"
            ;;
        p)  BACKUPPORT="$OPTARG"
            ;;
        k)  SSHKEY="$OPTARG"
            ;;
        u)  SSHUSER="$OPTARG"
            ;;
        m)  RSYNCMODULE="$OPTARG"
            ;;
        o)  RSYNCOPT="$OPTARG"
            ;;
        l)  BACKUPLOG="$OPTARG"
            ;;
        d)  __BACKUPLIST="$__BACKUPLIST $OPTARG"
            ;;
    esac
done
shift $(( $OPTIND - 1 ))

# override with commandline arguments
if [ -n "$__BACKUPLIST" ]; then
    BACKUPLIST="$__BACKUPLIST"
fi


# check configuration and set default
checkvar () {
    unset _checkvar
    set +o nounset
    eval "_checkvar=\$$1"
    set -o nounset
    if [ -z "$_checkvar" ]; then
        if [ $# -eq 2 ]; then
            eval "$1=\"$2\""
        else
            warn "$1 is need to be set"
            exit 1
        fi
    fi
}


# check configrations and set default value if not yet
checkvar BACKUPHOST
checkvar BACKUPPORT "22"
checkvar SSHKEY
checkvar SSHUSER "$USER"
checkvar RSYNCMODULE
checkvar RSYNCOPT "--quiet -a --compress --hard-links --xattrs --delete --force --super --numeric-ids --relative --timeout 600"
checkvar BACKUPLOG "/var/log/rsync/backup.${BACKUPHOST}_${RSYNCMODULE}.log"
checkvar BACKUPLIST


# check owner and permission of ssh key
isexist "$SSHKEY"
if [ `stat -c %u $SSHKEY` -ne 0 ]; then
    warn "owner of sshkey is not root"
    exit 1
fi
if [ `stat -c %a $SSHKEY` -ne 600 ]; then
    warn "permission of sshkey is wrong"
    exit 1
fi


# check connectivity of host
ping -c 1 $BACKUPHOST > /dev/null
if [ $? -ne 0 ]; then
    warn "$BACKUPHOST seems to be down (ping)"
    exit 1
fi


# read directory list and merge them to one line
# get rid of needless '/' from first and last of line
DIRLIST=""
for line in `echo $BACKUPLIST | tr '\n' ' '`
do
    line=`echo $line | sed -e 's#/$##'`
    line=`echo $line | sed -e 's#^/##'`
    DIRLIST="$DIRLIST /$line"
done


# set lock
LOCKDIR=/var/lock/backup.${BACKUPHOST}_${BACKUPPORT}_${RSYNCMODULE}.lock
cleanup () {
    rmdir $LOCKDIR
    exit 1
}

mkdir $LOCKDIR || exit 1
trap "exit 1" HUP INT QUIT PIPE TERM
trap cleanup EXIT


# ready to rsync
rsync --log-file=$BACKUPLOG $RSYNCOPT \
    -e "ssh -l $SSHUSER -i $SSHKEY -p $BACKUPPORT" \
    $DIRLIST $BACKUPHOST::$RSYNCMODULE

if [ $? -ne 0 ]; then
    warn "something wrong on rsync"
    exit 1
fi
